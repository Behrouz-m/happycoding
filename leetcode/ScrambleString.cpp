#include <cassert>
#include <vector>
#include <algorithm>

using namespace std;

//https://leetcode.com/problems/scramble-string/
/*
87. Scramble String

Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.

Below is one possible representation of s1 = "great":

great
/    \
gr    eat
/ \    /  \
g   r  e   at
/ \
a   t
To scramble the string, we may choose any non-leaf node and swap its two children.

For example, if we choose the node "gr" and swap its two children, it produces a scrambled string "rgeat".

rgeat
/    \
rg    eat
/ \    /  \
r   g  e   at
/ \
a   t

We say that "rgeat" is a scrambled string of "great".

Similarly, if we continue to swap the children of nodes "eat" and "at", it produces a scrambled string "rgtae".

rgtae
/    \
rg    tae
/ \    /  \
r   g  ta  e
/ \
t   a

We say that "rgtae" is a scrambled string of "great".

Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.

Example 1:

Input: s1 = "great", s2 = "rgeat"

Output: true
Example 2:


Input: s1 = "abcde", s2 = "caebd"

Output: false

Observations:

Scramble string can be generated by swapping on the 2 children of any non-leaf nodes for multiple times.

In this sense, DP appears to be a good candidate. I was not able to figure out the solution. My attention
was on an attempt to have an O(N^3) DP by picturing 2 strings as a matrix (classic string DP) and examining sub matrixes
diagonally. A diagonal matrix indicates a scramble string match on two substring. Two diagonal matrixes connecting
diagonally can be merged as a longer scramble string match. However, I can't find such a solution in O(N^4)...

The idea is for any 2 substrings on s1 starting at index i and s2 starting at index j with same length m,
the splits can occur anywhere between (i, j) with length of n.

For s1.substr(i, m), splitting it into 2 segments with size n and m - n: s1[i to i + n), s1[i + n, i + m)

For s2.substr(j, m), splitting it into 2 segments with size n and m - n: s2[j to j + n), s2[j + n, j + m)

Since the segment on substring with size n can be done on both left side and right side, the split
on s2 can also be:

s2[j, j + m - n), s2[j + m - n to j + m)

Then the comparisons are done between segments with same length : s1[i to i + n) vs s2[j to j + n) and s1[i + n, i + m) vs s2[j + n, j + m)

s1[i to i + n) vs s2[j + m - n to j + m) and s1[i + n, i + m) vs s2[j, j + m - n)

Of course, there are 2 more mirrored cases since one could split n from right end of s1.substr as well. However, these two scenarios will
be covered later since n is in range of [1, m). When n is equal to m - n, these two cases will be covered.

If one follow the above algorithm exactly, a naive recursive solution can be built and run in O(N!) time. That's an ETL.
However, with earlier termination by simply checking if two substrings contains the exact same numbers of characters (assuming ASCII lowercase only),
the algorithm actually runs lighteningly fast without any memorization! See isScramble0.

The DP solution however, can be built with O(N^4) time and O(N^3) space.

The memorization is built upon another relatively rare
DP thought on string. One can find another example using this approach in leetcode 5 (Longest Palindromic Substring), which
uses a N by N array to store the intermediate states. Two indexes [i, j] indicate a substring from i to j.

For the problem here:

- The first dimension is the starting index of substring on s1;
- The second dimension is the starting index on substring on s2;
- The third dimension is the length of the substrings starting on i for s1 and j for s2;

Bottom-up DP will start from substring with length 1 and then ends at length of len(s1). For this particular problem, bottom up
DP is slower coz it has to visit and fill out values for all states. Top-down DP is better
for this case coz it computes sub-problem only when necessary. For this problem, ruling out an invalid
pair only takes O(n) time, which is very cheap. Therefore, one can tell a top-down DP shall run faster
than bottom-up.

Such an implementation is not given since isScramble0 is fast enough. Furthermore, the memorizatoin array for
top-down DP, in order to achieve earlier termination, will have to maintain 3 states: not-visited-yet, valid and invalid.
*/
class SolutionScrambleString {
public:
	//Bottom up DP, O(N^4) time and O(N^3) space
	bool isScramble(string s1, string s2) {
		size_t len1 = s1.length(), len2 = s2.length();
		if (len1 != len2) return false;
		vector<vector<vector<bool>>> memo(len1, vector<vector<bool>>(len1, vector<bool>(len1 + 1, false)));
		for (size_t m = 1; m <= len1; ++m)
			for (size_t i = 0; i + m <= len1; ++i)
				for (size_t j = 0; j + m <= len1; ++j) {
					if (1 == m)
						memo[i][j][1] = s1[i] == s2[j];
					else
						for (size_t n = 1; n < m && false == memo[i][j][m]; ++n)
							memo[i][j][m] = (true == memo[i][j][n] && true == memo[i + n][j + n][m - n]) || (true == memo[i][j + m - n][n] && true == memo[i + n][j][m - n]);
				}
		return true == memo[0][0][len1];
	}
	//Recursive search, no DP, no memorization but fastest coz of earlier termination
	//also due to the test cases leetcode gave and the nature of this problem
	bool isScramble0(string s1, string s2) {
		size_t len1 = s1.length(), len2 = s2.length();
		if (len1 != len2) return false;
		auto f = [&s1, &s2](int i1, int i2, int len, const auto& fun) {
			if (1 == len) return s1[i1] == s2[i2];
			int cnt[26] = { 0 };
			bool ans = false;
			for (int i = 0; i < len; ++i) {
				++cnt[s1[i1 + i] - 'a'];
				--cnt[s2[i2 + i] - 'a'];
			}
			for (int i = 0; i < 26; ++i) if (0 != cnt[i]) return ans;
			for (int i = 1; i < len && false == ans; ++i)
				ans = (true == fun(i1, i2, i, fun) && true == fun(i1 + i, i2 + i, len - i, fun)) || (true == fun(i1, i2 + len - i, i, fun) && true == fun(i1 + i, i2, len - i, fun));
			return ans;
		};
		return f(0, 0, len1, f);
	}
};
void TestScrambleString() {
	SolutionScrambleString so;
	assert(true == so.isScramble("abc", "bca"));
	assert(true == so.isScramble("rgtae", "great"));
}
/*
Test cases:

"abc"
"bca"
"bca"
"abc"
"abb"
"bba"
"bba"
"abb"
"abca"
"bcaa"
"bcaa"
"abca"
"abcdefg"
"bcafedg"
"great"
"rgeat"
"great"
"taerg"
"rgtae"
"great"
"abcde"
"caebd"
"aa"
"aa"
"xerox"
"xexor"
"xeror"
"exxor"
"a"
"b"

Outputs:

true
true
true
true
true
true
true
true
true
true
false
true
true
false
false
*/