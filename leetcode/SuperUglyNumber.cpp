#include <vector>
#include <limits>
#include <algorithm>

using namespace std;

//https://leetcode.com/problems/super-ugly-number/
/*
313. Super Ugly Number

Write a program to find the nth super ugly number.

Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k.

Example:

Input: n = 12, primes = [2,7,13,19]

Output: 32

Explanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12
			 super ugly numbers given primes = [2,7,13,19] of size 4.
Note:

- 1 is a super ugly number for any given primes.
- The given numbers in primes are in ascending order.
- 0 < k <= 100, 0 < n <= 106, 0 < primes[i] < 1000.
- The nth super ugly number is guaranteed to fit in a 32-bit signed integer.

Observations:

This is esentially an extention of Ugly Number II (leetcode 264). The only difference is that the length
of given prime number array could vary. Instead of using 3 variables as indexes in leetcode 264, an array
has to be given for tracking the index on array uglyNumbers for each prime number.

As same as leetcode 264, can you discover the fact that all ugly numbers can be generated by multipling
each prime number in primes with every existing in-order ugly numbers.

[2, 3, 5], how can we get 30? Well, before getting there, you alreay have [1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15...]
as ugly numbers. With existing ugly numbers, getting 30 is for sure.

"The given numbers in primes are in ascending order" doesn't seem to play any role for solving the problem...

Overall O(kn) time and O(n) space.
*/
class SolutionSuperUglyNumber {
public:
	int nthSuperUglyNumber(int n, vector<int>& primes) {
		int cnt = 0, lenp = (int)primes.size();
		vector<int> uglyNumbers(n, std::numeric_limits<int>::max()), indexes(lenp, 0);
		uglyNumbers[0] = 1;
		while (++cnt < n) {
			for (int i = 0; i < lenp; ++i) uglyNumbers[cnt] = std::min(uglyNumbers[cnt], uglyNumbers[indexes[i]] * primes[i]);
			for (int i = 0; i < lenp; ++i) if (uglyNumbers[cnt] == uglyNumbers[indexes[i]] * primes[i]) ++indexes[i];
		}
		return uglyNumbers[n - 1];
	}
};
/*
Test cases:

5
[2,7,17,19]
7
[2,7,17,19]
8
[2,7,17,19]
12
[2,7,17,19]
109
[2,7,17,19]
8
[2]
90
[11,17,19,23]

Outputs:

8
16
17
34
8704
128
1088153
*/